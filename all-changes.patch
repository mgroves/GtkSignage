diff --git a/.gitignore b/.gitignore
index 28a0eb2..c5e2486 100644
--- a/.gitignore
+++ b/.gitignore
@@ -53,3 +53,6 @@ slides.json.lock
 # cached files
 /cache
 /signage/uploads
+
+# flatpak
+.flatpak-builder
\ No newline at end of file
diff --git a/main.py b/main.py
old mode 100644
new mode 100755
index 95885b0..e1cc795
--- a/main.py
+++ b/main.py
@@ -1,79 +1,126 @@
+#!/usr/bin/env python3
 """
 GTK Signage Application - Main Entry Point
 
-This script serves as the entry point for the GTK Signage application.
-It starts a Flask web server in a background thread for administration
-and initializes the GTK window for displaying slides.
+Starts:
+- Flask admin server (background thread)
+- GTK display window (foreground)
 
-The application combines a web-based admin interface with a GTK-based
-display that shows slides according to configured settings.
+Configuration is loaded from an INI file via signage.config.
 """
 
+from __future__ import annotations
+
 import sys
 import threading
 import logging
-import os
 import time
+from logging.handlers import RotatingFileHandler
+from pathlib import Path
 
 import gi
 gi.require_version("Gtk", "3.0")
 from gi.repository import Gtk
 
+from signage.config import load_config, get_config_path
 from signage.server import run_flask
 from signage.ui import SignageWindow
 from signage.cec_watchdog import ensure_cec_on_if_needed
-from logging.handlers import RotatingFileHandler
 
-# Configure root logger to output to stderr only
+
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
+
+config = load_config()
+
+LOG_LEVEL = config.get("logging", "level", fallback="INFO").upper()
+LOG_FILE = config.get("logging", "file", fallback="gtk_signage.log")
+LOG_MAX_BYTES = config.getint("logging", "max_bytes", fallback=10_485_760)  # 10 MB
+LOG_BACKUP_COUNT = config.getint("logging", "backup_count", fallback=3)
+
+
+# ------------------------------------------------------------
+# Logging setup
+# ------------------------------------------------------------
+
 logger = logging.getLogger()
 logger.setLevel(logging.INFO)
 
-# Log format
-log_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+log_format = logging.Formatter(
+    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+)
 
-# Console handler (stderr)
+# Console (stderr)
 console_handler = logging.StreamHandler(sys.stderr)
 console_handler.setFormatter(log_format)
 logger.addHandler(console_handler)
 
-# log to file, keep it from getting too big
-log_file = os.getenv("LOG_FILE", "gtk_signage.log")  # Default to current dir
-max_bytes = int(os.getenv("LOG_MAX_BYTES", 10_485_760))  # 10 MB max size
-backup_count = int(os.getenv("LOG_BACKUP_COUNT", 3))    # Keep 3 backups
-
-file_handler = RotatingFileHandler(log_file, maxBytes=max_bytes, backupCount=backup_count)
+# File logging
+log_path = Path(LOG_FILE).expanduser()
+file_handler = RotatingFileHandler(
+    log_path,
+    maxBytes=LOG_MAX_BYTES,
+    backupCount=LOG_BACKUP_COUNT,
+)
 file_handler.setFormatter(log_format)
 logger.addHandler(file_handler)
 
-# Set log level from environment variable if available
-log_level = os.getenv("LOG_LEVEL", "INFO").upper()
-if log_level in ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]:
-    logger.setLevel(getattr(logging, log_level))
+# Apply configured log level
+if hasattr(logging, LOG_LEVEL):
+    logger.setLevel(getattr(logging, LOG_LEVEL))
+
+logging.info("Logging initialized at %s level", LOG_LEVEL)
+logging.info("Using config file: %s", get_config_path())
 
-logging.info(f"Logging initialized at {log_level} level")
+
+# ------------------------------------------------------------
+# Background threads
+# ------------------------------------------------------------
 
 def run_cec_watchdog():
+    interval = config.getint("cec", "poll_seconds", fallback=300)
+
     while True:
         try:
             ensure_cec_on_if_needed()
-            time.sleep(300)  # Check every five minutes
-        except Exception as e:
-            logging.error(f"CEC watchdog error: {e}")
+        except Exception as exc:
+            logging.error("CEC watchdog error: %s", exc)
 
-if __name__ == "__main__":
+        time.sleep(interval)
+
+
+# ------------------------------------------------------------
+# Main
+# ------------------------------------------------------------
+
+def main() -> None:
     try:
-        # Start CEC watchdog thread
-        cec_thread = threading.Thread(target=run_cec_watchdog, daemon=True)
+        # Start CEC watchdog (if enabled internally)
+        cec_thread = threading.Thread(
+            target=run_cec_watchdog,
+            daemon=True,
+            name="cec-watchdog",
+        )
         cec_thread.start()
 
-        # Run Flask in a background daemon thread
-        flask_thread = threading.Thread(target=run_flask, daemon=True)
+        # Start Flask admin server
+        flask_thread = threading.Thread(
+            target=run_flask,
+            daemon=True,
+            name="flask-server",
+        )
         flask_thread.start()
 
-        logging.info("Starting GTK...")
-        win = SignageWindow()
+        logging.info("Starting GTKâ€¦")
+        SignageWindow()
         Gtk.main()
+
     except KeyboardInterrupt:
         logging.info("Caught Ctrl+C, shutting down.")
         Gtk.main_quit()
         sys.exit(0)
+
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/signage/cache.py b/signage/cache.py
index ce77f8f..80f4fef 100644
--- a/signage/cache.py
+++ b/signage/cache.py
@@ -1,295 +1,214 @@
 """
 Cache Module
 
-This module provides functionality for caching URL content locally.
-It handles downloading and caching HTML and supporting files (JS, CSS, images),
-as well as managing cache expiration and cleanup.
+Provides functionality for caching URL content locally.
+Handles downloading HTML and supporting files (JS, CSS, images),
+cache expiration, and cleanup.
 """
-import os
+
+from __future__ import annotations
+
 import time
 import logging
 import hashlib
 import shutil
-import re
+import os
 import urllib.parse
 from datetime import datetime, timedelta
 from pathlib import Path
+
 import requests
 from bs4 import BeautifulSoup
-from dotenv import load_dotenv
 
-# Get logger for this module
-logger = logging.getLogger(__name__)
+from signage.config import get_int, get_path
 
-# Load environment variables
-load_dotenv()
+logger = logging.getLogger(__name__)
 
-# Default cache settings
-DEFAULT_CACHE_DIR = "cache"
-DEFAULT_CACHE_EXPIRY_HOURS = 48
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
 
-# Get cache settings from environment variables
-CACHE_DIR = os.getenv("CACHE_DIR", DEFAULT_CACHE_DIR)
-CACHE_EXPIRY_HOURS = int(os.getenv("CACHE_EXPIRY_HOURS", DEFAULT_CACHE_EXPIRY_HOURS))
+CACHE_DIR: Path = get_path("cache", "dir", default="cache")
+CACHE_EXPIRY_HOURS: int = get_int("cache", "expiry_hours", default=48)
 
 
 class URLCache:
     """
-    A class for caching URL content locally.
-    
-    This class provides methods for downloading and caching HTML and supporting files,
-    as well as managing cache expiration and cleanup.
+    Utility class for caching URL content locally.
     """
-    
+
+    # ------------------------------------------------------------
+    # Paths
+    # ------------------------------------------------------------
+
+    @classmethod
+    def _ensure_cache_dir(cls) -> None:
+        if not CACHE_DIR.exists():
+            logger.info("Creating cache directory: %s", CACHE_DIR)
+            CACHE_DIR.mkdir(parents=True, exist_ok=True)
+
     @classmethod
-    def get_cache_path(cls, url):
+    def get_cache_path(cls, url: str) -> Path:
         """
-        Get the cache path for a URL.
-        
-        Args:
-            url (str): The URL to get the cache path for.
-            
-        Returns:
-            Path: The path to the cached file.
+        Return path to cached HTML file for a URL.
         """
-        # Create a hash of the URL to use as the filename
+        cls._ensure_cache_dir()
         url_hash = hashlib.md5(url.encode()).hexdigest()
-        
-        # Create the cache directory if it doesn't exist
-        cache_dir = Path(CACHE_DIR)
-        if not cache_dir.exists():
-            logger.info(f"Creating cache directory: {cache_dir}")
-            cache_dir.mkdir(parents=True, exist_ok=True)
-        
-        # Return the path to the cached file
-        return cache_dir / f"{url_hash}.html"
-    
+        return CACHE_DIR / f"{url_hash}.html"
+
     @classmethod
-    def get_cache_dir_for_url(cls, url):
+    def get_cache_dir_for_url(cls, url: str) -> Path:
         """
-        Get the cache directory for a URL's supporting files.
-        
-        Args:
-            url (str): The URL to get the cache directory for.
-            
-        Returns:
-            Path: The path to the cache directory for the URL.
+        Return directory for cached supporting files for a URL.
         """
-        # Create a hash of the URL to use as the directory name
+        cls._ensure_cache_dir()
         url_hash = hashlib.md5(url.encode()).hexdigest()
-        
-        # Create the cache directory if it doesn't exist
-        cache_dir = Path(CACHE_DIR) / url_hash
-        if not cache_dir.exists():
-            logger.info(f"Creating cache directory for URL: {cache_dir}")
-            cache_dir.mkdir(parents=True, exist_ok=True)
-        
-        return cache_dir
-    
+        path = CACHE_DIR / url_hash
+        path.mkdir(parents=True, exist_ok=True)
+        return path
+
+    # ------------------------------------------------------------
+    # Cache status
+    # ------------------------------------------------------------
+
     @classmethod
-    def is_cached(cls, url):
-        """
-        Check if a URL is cached.
-        
-        Args:
-            url (str): The URL to check.
-            
-        Returns:
-            bool: True if the URL is cached, False otherwise.
-        """
-        cache_path = cls.get_cache_path(url)
-        return cache_path.exists()
-    
+    def is_cached(cls, url: str) -> bool:
+        return cls.get_cache_path(url).exists()
+
     @classmethod
-    def is_cache_expired(cls, url):
-        """
-        Check if the cache for a URL is expired.
-        
-        Args:
-            url (str): The URL to check.
-            
-        Returns:
-            bool: True if the cache is expired, False otherwise.
-        """
+    def is_cache_expired(cls, url: str) -> bool:
         cache_path = cls.get_cache_path(url)
         if not cache_path.exists():
             return True
-        
-        # Get the modification time of the cached file
+
         mtime = cache_path.stat().st_mtime
-        mtime_dt = datetime.fromtimestamp(mtime)
-        
-        # Check if the cache is expired
         expiry_time = datetime.now() - timedelta(hours=CACHE_EXPIRY_HOURS)
-        return mtime_dt < expiry_time
-    
+        return datetime.fromtimestamp(mtime) < expiry_time
+
+    # ------------------------------------------------------------
+    # Caching
+    # ------------------------------------------------------------
+
     @classmethod
-    def cache_url(cls, url):
+    def cache_url(cls, url: str) -> bool:
         """
         Cache a URL and its supporting files.
-        
-        Args:
-            url (str): The URL to cache.
-            
-        Returns:
-            bool: True if the URL was cached successfully, False otherwise.
         """
-        logger.info(f"Caching URL: {url}")
-        
+        logger.info("Caching URL: %s", url)
+
         try:
-            # Download the HTML content
             response = requests.get(url, timeout=10)
             response.raise_for_status()
             html_content = response.text
-            
-            # Parse the HTML to find supporting files
-            soup = BeautifulSoup(html_content, 'html.parser')
-            
-            # Get the base URL for resolving relative URLs
+
+            soup = BeautifulSoup(html_content, "html.parser")
+
             base_url = url
-            base_tag = soup.find('base')
-            if base_tag and base_tag.get('href'):
-                base_url = urllib.parse.urljoin(url, base_tag['href'])
-            
-            # Cache supporting files
+            base_tag = soup.find("base")
+            if base_tag and base_tag.get("href"):
+                base_url = urllib.parse.urljoin(url, base_tag["href"])
+
             cache_dir = cls.get_cache_dir_for_url(url)
-            url_hash = hashlib.md5(url.encode()).hexdigest()
-            
-            # Cache CSS files and update references
-            for css_tag in soup.find_all('link', rel='stylesheet'):
-                if css_tag.get('href'):
-                    success, cache_filename, original_url = cls._cache_supporting_file(css_tag['href'], base_url, cache_dir, 'css')
-                    if success and cache_filename:
-                        # Update the href to point to the cached file with absolute file:// URL
-                        cached_file_path = cache_dir / cache_filename
-                        css_tag['href'] = f"file://{cached_file_path.absolute()}"
-            
-            # Cache JavaScript files and update references
-            for js_tag in soup.find_all('script', src=True):
-                success, cache_filename, original_url = cls._cache_supporting_file(js_tag['src'], base_url, cache_dir, 'js')
-                if success and cache_filename:
-                    # Update the src to point to the cached file with absolute file:// URL
-                    cached_file_path = cache_dir / cache_filename
-                    js_tag['src'] = f"file://{cached_file_path.absolute()}"
-            
-            # Cache images and update references
-            for img_tag in soup.find_all('img', src=True):
-                success, cache_filename, original_url = cls._cache_supporting_file(img_tag['src'], base_url, cache_dir, 'img')
-                if success and cache_filename:
-                    # Update the src to point to the cached file with absolute file:// URL
-                    cached_file_path = cache_dir / cache_filename
-                    img_tag['src'] = f"file://{cached_file_path.absolute()}"
-            
-            # Cache the modified HTML content
+
+            # Stylesheets
+            for tag in soup.find_all("link", rel="stylesheet"):
+                if tag.get("href"):
+                    success, filename = cls._cache_supporting_file(
+                        tag["href"], base_url, cache_dir, "css"
+                    )
+                    if success:
+                        tag["href"] = f"file://{(cache_dir / filename).absolute()}"
+
+            # Scripts
+            for tag in soup.find_all("script", src=True):
+                success, filename = cls._cache_supporting_file(
+                    tag["src"], base_url, cache_dir, "js"
+                )
+                if success:
+                    tag["src"] = f"file://{(cache_dir / filename).absolute()}"
+
+            # Images
+            for tag in soup.find_all("img", src=True):
+                success, filename = cls._cache_supporting_file(
+                    tag["src"], base_url, cache_dir, "img"
+                )
+                if success:
+                    tag["src"] = f"file://{(cache_dir / filename).absolute()}"
+
             cache_path = cls.get_cache_path(url)
-            with open(cache_path, 'w', encoding='utf-8') as f:
-                f.write(str(soup))
-            
-            logger.info(f"Successfully cached URL: {url}")
+            cache_path.write_text(str(soup), encoding="utf-8")
+
+            logger.info("Successfully cached URL: %s", url)
             return True
-        
+
         except Exception as e:
-            logger.error(f"Error caching URL {url}: {e}")
+            logger.error("Error caching URL %s: %s", url, e)
             return False
-    
+
     @classmethod
-    def _cache_supporting_file(cls, relative_url, base_url, cache_dir, file_type):
-        """
-        Cache a supporting file (CSS, JS, image, etc.).
-        
-        Args:
-            relative_url (str): The relative URL of the file.
-            base_url (str): The base URL for resolving relative URLs.
-            cache_dir (Path): The directory to cache the file in.
-            file_type (str): The type of file (css, js, img, etc.).
-            
-        Returns:
-            tuple: (bool, str, str) - Success status, cached filename, and original URL.
-                   If caching failed, returns (False, None, None).
-        """
+    def _cache_supporting_file(
+        cls,
+        relative_url: str,
+        base_url: str,
+        cache_dir: Path,
+        file_type: str,
+    ) -> tuple[bool, str | None]:
         try:
-            # Resolve the absolute URL
             absolute_url = urllib.parse.urljoin(base_url, relative_url)
-            
-            # Create a filename for the cached file
             url_hash = hashlib.md5(absolute_url.encode()).hexdigest()
-            
-            # Extract the file extension from the URL
-            parsed_url = urllib.parse.urlparse(absolute_url)
-            path = parsed_url.path
-            extension = os.path.splitext(path)[1]
-            if not extension:
-                extension = f".{file_type}"
-            
-            # Create the cache filename
-            cache_filename = f"{url_hash}{extension}"
-            cache_path = cache_dir / cache_filename
-            
-            # Download and cache the file
+
+            parsed = urllib.parse.urlparse(absolute_url)
+            ext = os.path.splitext(parsed.path)[1] or f".{file_type}"
+
+            filename = f"{url_hash}{ext}"
+            path = cache_dir / filename
+
             response = requests.get(absolute_url, timeout=10)
             response.raise_for_status()
-            
-            with open(cache_path, 'wb') as f:
-                f.write(response.content)
-            
-            logger.debug(f"Cached supporting file: {absolute_url} -> {cache_path}")
-            return True, cache_filename, relative_url
-        
+
+            path.write_bytes(response.content)
+
+            logger.debug("Cached %s -> %s", absolute_url, path)
+            return True, filename
+
         except Exception as e:
-            logger.error(f"Error caching supporting file {relative_url}: {e}")
-            return False, None, None
-    
+            logger.error("Error caching %s: %s", relative_url, e)
+            return False, None
+
+    # ------------------------------------------------------------
+    # Access
+    # ------------------------------------------------------------
+
     @classmethod
-    def get_cached_url(cls, url):
-        """
-        Get the cached URL.
-        
-        Args:
-            url (str): The original URL.
-            
-        Returns:
-            str: The file:// URL to the cached file, or the original URL if not cached.
-        """
+    def get_cached_url(cls, url: str) -> str:
         if not cls.is_cached(url):
             return url
-        
-        cache_path = cls.get_cache_path(url)
-        return f"file://{cache_path.absolute()}"
-    
+        return f"file://{cls.get_cache_path(url).absolute()}"
+
+    # ------------------------------------------------------------
+    # Cleanup
+    # ------------------------------------------------------------
+
     @classmethod
-    def cleanup_expired_cache(cls):
-        """
-        Clean up expired cache files.
-        
-        This method removes all cached files that are older than the expiry time.
-        """
+    def cleanup_expired_cache(cls) -> None:
         logger.info("Cleaning up expired cache files")
-        
+
+        if not CACHE_DIR.exists():
+            return
+
+        expiry_time = time.time() - (CACHE_EXPIRY_HOURS * 3600)
+
         try:
-            cache_dir = Path(CACHE_DIR)
-            if not cache_dir.exists():
-                logger.debug("Cache directory does not exist, nothing to clean up")
-                return
-            
-            # Get the expiry time
-            expiry_time = time.time() - (CACHE_EXPIRY_HOURS * 3600)
-            
-            # Check all files and directories in the cache directory
-            for item in cache_dir.iterdir():
-                if item.is_file():
-                    # Check if the file is expired
-                    mtime = item.stat().st_mtime
-                    if mtime < expiry_time:
-                        logger.debug(f"Removing expired cache file: {item}")
+            for item in CACHE_DIR.iterdir():
+                if item.stat().st_mtime < expiry_time:
+                    if item.is_file():
+                        logger.debug("Removing expired cache file: %s", item)
                         item.unlink()
-                elif item.is_dir():
-                    # Check if the directory is expired (based on the directory's mtime)
-                    mtime = item.stat().st_mtime
-                    if mtime < expiry_time:
-                        logger.debug(f"Removing expired cache directory: {item}")
+                    elif item.is_dir():
+                        logger.debug("Removing expired cache dir: %s", item)
                         shutil.rmtree(item)
-            
-            logger.info("Finished cleaning up expired cache files")
-        
+
+            logger.info("Cache cleanup complete")
+
         except Exception as e:
-            logger.error(f"Error cleaning up expired cache files: {e}")
\ No newline at end of file
+            logger.error("Cache cleanup failed: %s", e)
\ No newline at end of file
diff --git a/signage/cec_control.py b/signage/cec_control.py
index 3e294cb..d554218 100644
--- a/signage/cec_control.py
+++ b/signage/cec_control.py
@@ -1,48 +1,125 @@
-import os
+"""
+CEC Control Module
 
-# Determine if we're in fake/sim mode
-USE_FAKE_CEC = os.getenv("CEC_FAKE", "false").lower() == "true"
+Provides simple power status and control helpers for HDMI-CEC.
+Supports real and fake (simulated) modes via configuration.
+"""
+
+from __future__ import annotations
+
+import logging
+
+from signage.config import get_bool
+
+logger = logging.getLogger(__name__)
+
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
+
+USE_FAKE_CEC = get_bool("cec", "fake", default=False)
+
+# ------------------------------------------------------------
+# Internal state (fake mode)
+# ------------------------------------------------------------
 
-# Internal state for fake mode
 _fake_status = "Off"
 
-try:
-    if not USE_FAKE_CEC:
+# ------------------------------------------------------------
+# Optional CEC initialization
+# ------------------------------------------------------------
+
+adapter = None
+CEC_AVAILABLE = False
+
+if not USE_FAKE_CEC:
+    try:
         import cec
+
         cec_config = cec.libcec_configuration()
-        cec_config.strDeviceName = "pyCec"
+        cec_config.strDeviceName = "GtkSignage"
         cec_config.clientVersion = cec.LIBCEC_VERSION_CURRENT
+
         adapter = cec.ICECAdapter.Create(cec_config)
-        com_ports = adapter.DetectAdapters()
-        if com_ports:
-            adapter.Open(com_ports[0].strComName)
-        else:
-            raise Exception("No CEC adapters found")
-except Exception as e:
-    adapter = None
-    if not USE_FAKE_CEC:
-        print(f"CEC init error: {e}")
+        adapters = adapter.DetectAdapters()
+
+        if not adapters:
+            raise RuntimeError("No CEC adapters found")
+
+        if not adapter.Open(adapters[0].strComName):
+            raise RuntimeError("Failed to open CEC adapter")
+
+        CEC_AVAILABLE = True
+        logger.info("CEC control initialized")
+
+    except Exception as e:
+        adapter = None
+        CEC_AVAILABLE = False
+        logger.warning("CEC unavailable, falling back to fake mode: %s", e)
         USE_FAKE_CEC = True
 
-def get_cec_status():
+
+# ------------------------------------------------------------
+# Public API
+# ------------------------------------------------------------
+
+def get_cec_status() -> str:
+    """
+    Return current power status as 'On' or 'Off'.
+    """
     if USE_FAKE_CEC:
         return _fake_status
+
+    if not CEC_AVAILABLE or not adapter:
+        return "Unavailable"
+
     try:
-        status = adapter.GetDevicePowerStatus(0)
+        status = adapter.GetDevicePowerStatus(0)  # 0 = TV
         return "On" if status == cec.CEC_POWER_STATUS_ON else "Off"
     except Exception as e:
-        return f"Error: {e}"
+        logger.error("CEC status check failed: %s", e)
+        return "Error"
 
-def cec_power_on():
+
+def cec_power_on() -> None:
+    """
+    Power on the display.
+    """
     global _fake_status
+
     if USE_FAKE_CEC:
         _fake_status = "On"
-    else:
+        logger.debug("CEC fake mode: power ON")
+        return
+
+    if not CEC_AVAILABLE or not adapter:
+        logger.warning("CEC power on requested but unavailable")
+        return
+
+    try:
         adapter.PowerOnDevices(0)
+        logger.info("CEC power ON sent")
+    except Exception as e:
+        logger.error("CEC power ON failed: %s", e)
 
-def cec_power_off():
+
+def cec_power_off() -> None:
+    """
+    Put the display into standby.
+    """
     global _fake_status
+
     if USE_FAKE_CEC:
         _fake_status = "Off"
-    else:
+        logger.debug("CEC fake mode: power OFF")
+        return
+
+    if not CEC_AVAILABLE or not adapter:
+        logger.warning("CEC power off requested but unavailable")
+        return
+
+    try:
         adapter.StandbyDevices(0)
+        logger.info("CEC power OFF sent")
+    except Exception as e:
+        logger.error("CEC power OFF failed: %s", e)
\ No newline at end of file
diff --git a/signage/cec_watchdog.py b/signage/cec_watchdog.py
index d99c489..390bb81 100644
--- a/signage/cec_watchdog.py
+++ b/signage/cec_watchdog.py
@@ -1,65 +1,103 @@
-import os
-import time
+"""
+CEC Watchdog Module
+
+Controls HDMI-CEC power state based on configured time windows.
+CEC support is optional and safely disabled if unavailable.
+"""
+
+from __future__ import annotations
+
 import logging
 from datetime import datetime, time as dtime
-from dotenv import load_dotenv
 
-load_dotenv()
+from signage.config import get_bool, get_time
 
 logger = logging.getLogger(__name__)
 
+# ------------------------------------------------------------
+# Optional CEC import
+# ------------------------------------------------------------
+
+CEC_AVAILABLE = False
+cec_lib = None
+
 try:
     import cec
 
-    CEC_AVAILABLE = True
-
     cec_config = cec.libcec_configuration()
     cec_config.strDeviceName = "GtkSignage"
     cec_config.bActivateSource = 0
     cec_config.deviceTypes.Add(cec.CEC_DEVICE_TYPE_RECORDING_DEVICE)
+
     cec_lib = cec.ICECAdapter.Create(cec_config)
 
-    if not cec_lib.DetectAdapters():
-        logger.warning("No CEC adapters found. CEC control disabled.")
-        CEC_AVAILABLE = False
-    elif not cec_lib.Open(cec_lib.DetectAdapters()[0].strComName):
-        logger.warning("Failed to open CEC adapter. CEC control disabled.")
-        CEC_AVAILABLE = False
+    adapters = cec_lib.DetectAdapters()
+    if not adapters:
+        logger.warning("No CEC adapters found. CEC disabled.")
+    elif not cec_lib.Open(adapters[0].strComName):
+        logger.warning("Failed to open CEC adapter. CEC disabled.")
+    else:
+        CEC_AVAILABLE = True
+        logger.info("CEC adapter initialized successfully.")
 
 except ImportError:
-    CEC_AVAILABLE = False
-    logger.warning("CEC module not available. Skipping CEC watchdog.")
-
+    logger.warning("CEC Python module not available. Skipping CEC watchdog.")
 
-def parse_time(timestr):
-    return dtime.fromisoformat(timestr.strip())
 
+# ------------------------------------------------------------
+# Helpers
+# ------------------------------------------------------------
 
 def is_now_between(start: dtime, end: dtime) -> bool:
+    """
+    Check whether current local time falls between start and end.
+    Handles windows that cross midnight.
+    """
     now = datetime.now().time()
-    return start <= now <= end if start < end else now >= start or now <= end
 
+    if start < end:
+        return start <= now <= end
+    else:
+        return now >= start or now <= end
+
+
+def is_cec_on() -> bool:
+    """
+    Check whether the display is currently powered on via CEC.
+    """
+    if not CEC_AVAILABLE or not cec_lib:
+        return False
 
-def is_cec_on():
     power = cec_lib.GetDevicePowerStatus(0)  # 0 = TV
     return power == cec.CEC_POWER_STATUS_ON
 
 
-def ensure_cec_on_if_needed():
+# ------------------------------------------------------------
+# Public API
+# ------------------------------------------------------------
+
+def ensure_cec_on_if_needed() -> None:
+    """
+    Ensure the display is powered on during configured hours.
+    Safe no-op if CEC is disabled or unavailable.
+    """
     if not CEC_AVAILABLE:
         return
 
-    if os.getenv("CEC_ENABLE", "false").lower() != "true":
+    if not get_bool("cec", "enable", default=False):
         return
 
-    start = parse_time(os.getenv("CEC_START", "10:00"))
-    end = parse_time(os.getenv("CEC_END", "22:00"))
+    start = get_time("cec", "start", default="10:00")
+    end = get_time("cec", "end", default="22:00")
 
     if is_now_between(start, end):
         if not is_cec_on():
-            logger.info("CEC within active hours, turning TV ON...")
-            cec_lib.PowerOnDevices()
+            logger.info("CEC active window: powering ON display.")
+            try:
+                cec_lib.PowerOnDevices()
+            except Exception as e:
+                logger.error("CEC power-on failed: %s", e)
         else:
-            logger.debug("CEC already ON.")
+            logger.debug("CEC display already ON.")
     else:
-        logger.debug("CEC outside active hours.")
+        logger.debug("Outside CEC active window.")
\ No newline at end of file
diff --git a/signage/jsonfile.py b/signage/jsonfile.py
index c7bb46d..71fb702 100644
--- a/signage/jsonfile.py
+++ b/signage/jsonfile.py
@@ -1,95 +1,83 @@
 """
 JSON File Handler Module
 
-This module provides functionality for safely reading from and writing to JSON files
-with file locking to prevent concurrent access issues.
+Safe JSON read/write with file locking.
+All files are stored in the configured data directory.
 """
+
+from __future__ import annotations
+
 import json
 import logging
 from pathlib import Path
+from typing import Any
 
 from filelock import FileLock
 
-# Get logger for this module
+from signage.config import get_data_dir
+
 logger = logging.getLogger(__name__)
 
+
 class JSONFileHandler:
     """
-    A class for handling JSON file operations with file locking.
-    
-    This class provides methods to safely read from and write to JSON files
-    with file locking to prevent data corruption from concurrent access.
+    Handles JSON file operations with file locking.
     """
-    def __init__(self, filename):
+
+    def __init__(self, filename: str):
         """
-        Initialize a JSONFileHandler instance.
-        
         Args:
-            filename (str): Path to the JSON file to be handled.
+            filename: Filename only (no path). Stored under data dir.
         """
-        self.file_path = Path(filename)
-        self.lock = FileLock(f"{filename}.lock")
+        if "/" in filename or "\\" in filename:
+            raise ValueError("filename must not contain path separators")
+
+        data_dir = get_data_dir()
+        self.file_path: Path = data_dir / filename
+        self.lock = FileLock(str(self.file_path) + ".lock")
+
+    # ------------------------------------------------------------
+    # Read
+    # ------------------------------------------------------------
 
-    def load(self):
+    def load(self) -> Any:
         """
-        Load data from the JSON file with file locking.
-        
+        Load JSON data from disk.
+
         Returns:
-            list or dict: The data loaded from the JSON file, or an empty list if the file doesn't exist.
-            
-        Note:
-            This method acquires a file lock before reading to prevent concurrent access issues.
+            Parsed JSON data, or empty list if missing or invalid.
         """
-        logger.debug(f"Acquiring lock for reading: {self.file_path}")
         with self.lock:
-            logger.debug(f"Lock acquired for reading: {self.file_path}")
             if not self.file_path.exists():
-                logger.info(f"File does not exist, returning empty list: {self.file_path}")
+                logger.info("JSON file not found, returning empty list: %s", self.file_path)
                 return []
+
             try:
-                with self.file_path.open("r", encoding="utf-8") as file:
-                    logger.debug(f"Reading file: {self.file_path}")
-                    data = json.load(file)
-                    logger.debug(f"Successfully loaded data from: {self.file_path}")
-                    return data
+                with self.file_path.open("r", encoding="utf-8") as f:
+                    return json.load(f)
             except json.JSONDecodeError as e:
-                logger.error(f"JSON decode error in {self.file_path}: {e}")
+                logger.error("Invalid JSON in %s: %s", self.file_path, e)
                 return []
             except Exception as e:
-                logger.error(f"Error reading {self.file_path}: {e}")
+                logger.error("Error reading %s: %s", self.file_path, e)
                 return []
 
-    def save(self, data):
+    # ------------------------------------------------------------
+    # Write
+    # ------------------------------------------------------------
+
+    def save(self, data: Any) -> None:
         """
-        Save data to the JSON file with file locking.
-        
-        Args:
-            data (list or dict): The data to be saved to the JSON file.
-            
-        Note:
-            This method acquires a file lock before writing to prevent concurrent access issues.
-            The data is saved with an indent of 4 spaces for readability.
+        Save JSON data to disk.
+
+        Raises on write failure.
         """
-        logger.debug(f"Acquiring lock for writing: {self.file_path}")
         with self.lock:
-            logger.debug(f"Lock acquired for writing: {self.file_path}")
             try:
-                # Ensure parent directory exists
-                parent_dir = self.file_path.parent
-                if not parent_dir.exists():
-                    logger.info(f"Creating parent directory: {parent_dir}")
-                    parent_dir.mkdir(parents=True, exist_ok=True)
-                
-                logger.debug(f"Writing data to file: {self.file_path}")
-                with self.file_path.open("w", encoding="utf-8") as file:
-                    json.dump(data, file, indent=4)
-                logger.debug(f"Successfully saved data to: {self.file_path}")
-            except PermissionError as e:
-                logger.error(f"Permission error writing to {self.file_path}: {e}")
-                raise
-            except OSError as e:
-                logger.error(f"OS error writing to {self.file_path}: {e}")
-                raise
+                self.file_path.parent.mkdir(parents=True, exist_ok=True)
+
+                with self.file_path.open("w", encoding="utf-8") as f:
+                    json.dump(data, f, indent=4)
             except Exception as e:
-                logger.error(f"Unexpected error writing to {self.file_path}: {e}")
-                raise
+                logger.error("Error writing %s: %s", self.file_path, e)
+                raise
\ No newline at end of file
diff --git a/signage/models.py b/signage/models.py
index 4ec5288..d646b57 100644
--- a/signage/models.py
+++ b/signage/models.py
@@ -1,126 +1,94 @@
 """
 Models Module
 
-This module defines the data models used in the GTK Signage application.
-It contains the Slide class which represents a single slide in the signage system.
+Data models for the GTK Signage application.
 """
+
+from __future__ import annotations
+
 import logging
 from datetime import datetime
+from typing import Optional
 
-# Get logger for this module
 logger = logging.getLogger(__name__)
 
+
 class Slide:
     """
-    A class representing a slide in the signage system.
-    
-    A slide has a source (URL or file path), duration, optional start and end times,
-    and a flag to hide it from display.
+    Represents a single signage slide.
     """
-    def __init__(self, source, duration, start=None, end=None, hide=False):
-        """
-        Initialize a Slide instance.
-        
-        Args:
-            source (str): URL or file path to the slide content.
-            duration (int): Duration in seconds to display the slide.
-            start (datetime, optional): Start time when the slide becomes active. Defaults to None.
-            end (datetime, optional): End time when the slide becomes inactive. Defaults to None.
-            hide (bool, optional): Flag to hide the slide regardless of timing. Defaults to False.
-            
-        Raises:
-            ValueError: If any of the parameters are invalid.
-            TypeError: If any of the parameters have incorrect types.
-        """
-        # Validate source
-        if not isinstance(source, str):
-            raise TypeError("Source must be a string")
-        if not source.strip():
-            raise ValueError("Source cannot be empty")
-        
-        # Validate duration
-        if not isinstance(duration, int):
-            try:
-                duration = int(duration)
-            except (ValueError, TypeError):
-                raise TypeError("Duration must be an integer")
+
+    def __init__(
+        self,
+        source: str,
+        duration: int,
+        start: Optional[datetime] = None,
+        end: Optional[datetime] = None,
+        hide: bool = False,
+    ):
+        # ---- Validate source -------------------------------------
+        if not isinstance(source, str) or not source.strip():
+            raise ValueError("source must be a non-empty string")
+
+        # ---- Validate duration -----------------------------------
+        try:
+            duration = int(duration)
+        except (TypeError, ValueError):
+            raise TypeError("duration must be an integer")
+
         if duration <= 0:
-            raise ValueError("Duration must be positive")
-            
-        # Validate start and end times
+            raise ValueError("duration must be positive")
+
+        # ---- Validate start / end --------------------------------
         if start is not None and not isinstance(start, datetime):
-            raise TypeError("Start time must be a datetime object")
+            raise TypeError("start must be a datetime or None")
+
         if end is not None and not isinstance(end, datetime):
-            raise TypeError("End time must be a datetime object")
+            raise TypeError("end must be a datetime or None")
+
         if start and end and start >= end:
-            raise ValueError("Start time must be before end time")
-            
-        # Validate hide flag
+            raise ValueError("start must be before end")
+
+        # ---- Validate hide ---------------------------------------
         if not isinstance(hide, bool):
-            raise TypeError("Hide flag must be a boolean")
-            
-        self.source = source
-        self.duration = duration
-        self.start = start if start else None
-        self.end = end if end else None
-        self.hide = hide
-
-    def is_active(self):
+            raise TypeError("hide must be boolean")
+
+        self.source: str = source
+        self.duration: int = duration
+        self.start: Optional[datetime] = start
+        self.end: Optional[datetime] = end
+        self.hide: bool = hide
+
+    # ------------------------------------------------------------
+    # State
+    # ------------------------------------------------------------
+
+    def is_active(self, now: Optional[datetime] = None) -> bool:
         """
-        Determine if the slide is currently active and should be displayed.
-        
-        A slide is active if:
-        - It is not hidden
-        - The current time is within its start and end times (if specified)
-        
-        Returns:
-            bool: True if the slide is active and should be displayed, False otherwise.
+        Determine whether this slide should currently be displayed.
         """
-        # Get a short identifier for the slide for logging
-        slide_id = self.source.split('/')[-1] if '/' in self.source else self.source
-        
         if self.hide:
-            logger.debug(f"Slide '{slide_id}' is inactive: manually hidden")
             return False
 
-        now = datetime.now()
-        logger.debug(f"Checking if slide '{slide_id}' is active at {now.isoformat()}")
-
-        # No time constraints
-        if not self.start and not self.end:
-            logger.debug(f"Slide '{slide_id}' is active: no time constraints")
-            return True
-
-        # Only end time constraint
-        if not self.start and self.end:
-            is_active = now <= self.end
-            if is_active:
-                logger.debug(f"Slide '{slide_id}' is active: current time is before end time {self.end.isoformat()}")
-            else:
-                logger.debug(f"Slide '{slide_id}' is inactive: current time is after end time {self.end.isoformat()}")
-            return is_active
-
-        # Only start time constraint
-        if self.start and not self.end:
-            is_active = now >= self.start
-            if is_active:
-                logger.debug(f"Slide '{slide_id}' is active: current time is after start time {self.start.isoformat()}")
-            else:
-                logger.debug(f"Slide '{slide_id}' is inactive: current time is before start time {self.start.isoformat()}")
-            return is_active
-
-        # Both start and end time constraints
-        if self.start and self.end:
-            is_active = self.start <= now <= self.end
-            if is_active:
-                logger.debug(f"Slide '{slide_id}' is active: current time is between start {self.start.isoformat()} and end {self.end.isoformat()}")
-            else:
-                if now < self.start:
-                    logger.debug(f"Slide '{slide_id}' is inactive: current time is before start time {self.start.isoformat()}")
-                else:
-                    logger.debug(f"Slide '{slide_id}' is inactive: current time is after end time {self.end.isoformat()}")
-            return is_active
-
-        logger.warning(f"Slide '{slide_id}' reached unexpected condition in is_active()")
-        return False
+        now = now or datetime.now()
+
+        if self.start and now < self.start:
+            return False
+
+        if self.end and now > self.end:
+            return False
+
+        return True
+
+    # ------------------------------------------------------------
+    # Debug / display
+    # ------------------------------------------------------------
 
+    def __repr__(self) -> str:
+        return (
+            f"Slide(source={self.source!r}, "
+            f"duration={self.duration}, "
+            f"start={self.start}, "
+            f"end={self.end}, "
+            f"hide={self.hide})"
+        )
\ No newline at end of file
diff --git a/signage/server.py b/signage/server.py
index 2119101..f091607 100644
--- a/signage/server.py
+++ b/signage/server.py
@@ -1,165 +1,164 @@
 """
 Server Module
 
-This module provides a Flask web server for the GTK Signage application.
-The server runs in a background thread
-alongside the GTK display window.
+Flask web server for GTK Signage.
+Runs in a background thread alongside the GTK display.
+Configuration is loaded from INI via signage.config.
 """
+
+from __future__ import annotations
+
+import logging
 import os
 import urllib.parse
 from datetime import datetime
-from functools import wraps
-import logging
 
-from dotenv import load_dotenv
-from flask import Flask, render_template, request, redirect, url_for, session, send_file, abort
-from flask import request, redirect
+from flask import (
+    Flask,
+    render_template,
+    request,
+    redirect,
+    send_file,
+    abort,
+)
 from flask_wtf.csrf import CSRFProtect, CSRFError
 
-from signage.models import Slide
+from signage.config import load_config
 from signage.slidestore import SlideStore
 from signage.routes.slides import slides_bp
 from signage.routes.auth import auth_bp
 from signage.helpers.auth import login_required
 
-load_dotenv()
-
-HOST = os.getenv("FLASK_HOST", "127.0.0.1")
-PORT = int(os.getenv("FLASK_PORT", 5000))
-USE_SSL = os.getenv("USE_SSL", "false").lower() == "true"
-
-app = Flask(__name__)
-app.secret_key = os.getenv("FLASK_SECRET_KEY")
-csrf = CSRFProtect(app)
 
+logger = logging.getLogger(__name__)
+config = load_config()
 
-# #######################################
-# blueprints for various routes and endpoints
-app.register_blueprint(slides_bp)
-app.register_blueprint(auth_bp)
-# #######################################
 
+# ------------------------------------------------------------
+# Flask app factory
+# ------------------------------------------------------------
 
-# Redirect HTTP to HTTPS if enabled
-if USE_SSL:
-    @app.before_request
-    def redirect_to_https():
-        if request.headers.get("X-Forwarded-Proto", "http") == "http" and request.url.startswith("http://"):
-            return redirect(request.url.replace("http://", "https://", 1), code=301)
-
-@app.errorhandler(CSRFError)
-def handle_csrf_error(e):
-    """
-    Handle CSRF errors by logging the error and returning an error message.
-    
-    Args:
-        e (CSRFError): The CSRF error that occurred.
-        
-    Returns:
-        Response: Error message with 400 status code.
+def create_app() -> Flask:
     """
-    logging.error(f"CSRF error: {e.description}")
-    return "CSRF token validation failed. Please try again.", 400
-
-# Template filters
-@app.template_filter('format_ampm')
-def format_ampm(value):
+    Create and configure the Flask application.
     """
-    Flask template filter to format datetime values in a user-friendly AM/PM format.
-    
-    Args:
-        value (str, datetime, None): The datetime value to format.
-            Can be a datetime object, ISO format string, or None.
-            
-    Returns:
-        str: Formatted date/time string in "m/d/yyyy h:MMam/pm" format,
-             or "N/A" if the value is invalid or represents a placeholder date.
-    """
-    if not value or str(value).strip() == "":
-        return "N/A"
-    try:
-        if isinstance(value, str):
-            dt = datetime.fromisoformat(value.strip())
-        elif isinstance(value, datetime):
-            dt = value
-        else:
+    app = Flask(__name__)
+
+    # ---- Security -------------------------------------------------
+    secret_key = config.get("server", "secret_key", fallback=None)
+    if not secret_key:
+        raise RuntimeError("Missing [server].secret_key in config")
+
+    app.secret_key = secret_key
+    csrf = CSRFProtect(app)
+
+    # ---- Blueprints ----------------------------------------------
+    app.register_blueprint(slides_bp)
+    app.register_blueprint(auth_bp)
+
+    # ---- HTTPS redirect (optional) -------------------------------
+    use_ssl = config.getboolean("server", "use_ssl", fallback=False)
+
+    if use_ssl:
+        @app.before_request
+        def redirect_to_https():
+            if (
+                request.headers.get("X-Forwarded-Proto", "http") == "http"
+                and request.url.startswith("http://")
+            ):
+                return redirect(
+                    request.url.replace("http://", "https://", 1),
+                    code=301,
+                )
+
+    # ---- CSRF error handler --------------------------------------
+    @app.errorhandler(CSRFError)
+    def handle_csrf_error(e):
+        logger.error("CSRF error: %s", e.description)
+        return "CSRF token validation failed.", 400
+
+    # ---- Template filters ----------------------------------------
+    @app.template_filter("format_ampm")
+    def format_ampm(value):
+        if not value or str(value).strip() == "":
             return "N/A"
-
-        # Filter out placeholder datetime extremes
-        if dt == datetime.min or dt == datetime.max:
+        try:
+            if isinstance(value, str):
+                dt = datetime.fromisoformat(value.strip())
+            elif isinstance(value, datetime):
+                dt = value
+            else:
+                return "N/A"
+
+            if dt in (datetime.min, datetime.max):
+                return "N/A"
+
+            return dt.strftime("%-m/%-d/%Y %-I:%M%p").lower()
+        except Exception:
             return "N/A"
 
-        return dt.strftime("%-m/%-d/%Y %-I:%M%p").lower()
-    except Exception:
-        return "N/A"
-
+    # ---- Internal image serving ----------------------------------
+    @app.route("/internal-image/<path:encoded_path>")
+    @login_required
+    def serve_internal_image(encoded_path):
+        full_path = urllib.parse.unquote(encoded_path)
+        if not full_path.startswith("/"):
+            full_path = "/" + full_path
 
-# Image serving routes
-@app.route("/internal-image/<path:encoded_path>")
-@login_required
-def serve_internal_image(encoded_path):
-    """
-    Serve internal images to authenticated admin users.
-    
-    This route decodes the URL-encoded path and serves the file if it exists.
-    It requires authentication to prevent unauthorized access to local files.
-    
-    Args:
-        encoded_path (str): URL-encoded file path.
-        
-    Returns:
-        Response: The image file response or a 404 error if the file doesn't exist.
-    """
-    full_path = urllib.parse.unquote(encoded_path)
+        if not os.path.isfile(full_path):
+            return abort(404)
 
-    # Ensure leading slash is restored if missing
-    if not full_path.startswith("/"):
-        full_path = "/" + full_path
+        return send_file(full_path, mimetype="image/*")
 
-    logging.debug(f"Attempting to serve actual file path: {full_path}")
+    # ---- Health / index ------------------------------------------
+    @app.route("/")
+    def index():
+        return render_template("index.html")
 
-    if not os.path.isfile(full_path):
-        logging.debug("File not found!")
-        return abort(404)
+    return app
 
-    return send_file(full_path, mimetype="image/*")
 
+# ------------------------------------------------------------
+# Entrypoint
+# ------------------------------------------------------------
 
-@app.route("/")
-def index():
+def run_flask() -> None:
     """
-    Render the main index page.
-    
-    This just shows that the server is running.
-    
-    Returns:
-        Response: Rendered index.html template.
+    Start the Flask server using config-defined host/port.
+    Intended to be run in a background thread.
     """
-    return render_template("index.html")
+    host = config.get("server", "host", fallback="127.0.0.1")
+    port = config.getint("server", "port", fallback=5000)
+    use_ssl = config.getboolean("server", "use_ssl", fallback=False)
 
+    logger.info("Flask server starting on %s:%s", host, port)
 
-# Entrypoint
-def run_flask():
-    """
-    Start the Flask web server.
-    
-    This function is the entry point for the Flask server component of the application.
-    It configures and starts the Flask server with the appropriate host, port, and SSL settings.
-    
-    The server is typically run in a background thread alongside the GTK window.
-    
-    SSL is enabled if USE_SSL is set to "true" in the environment variables and
-    the certificate files (cert.pem and key.pem) exist.
-    """
-    logging.info("Flask server starting...")
+    app = create_app()
 
     ssl_context = None
-    if USE_SSL:
-        cert_path = os.path.join(os.path.dirname(__file__), "..", "cert.pem")
-        key_path = os.path.join(os.path.dirname(__file__), "..", "key.pem")
-        if os.path.exists(cert_path) and os.path.exists(key_path):
-            ssl_context = (cert_path, key_path)
+    if use_ssl:
+        cert = config.get("server", "cert", fallback=None)
+        key = config.get("server", "key", fallback=None)
+
+        if cert and key and os.path.exists(cert) and os.path.exists(key):
+            ssl_context = (cert, key)
         else:
-            logging.warning("SSL requested but cert.pem or key.pem not found â€” continuing without SSL.")
+            logger.warning(
+                "SSL enabled but cert/key missing; starting without SSL"
+            )
 
-    app.run(host=HOST, port=PORT, ssl_context=ssl_context)
\ No newline at end of file
+    try:
+        app.run(
+            host=host,
+            port=port,
+            ssl_context=ssl_context,
+            debug=False,
+            use_reloader=False,  # critical for threaded GTK
+        )
+    except OSError as exc:
+        logger.error(
+            "Failed to start Flask server on %s:%s (%s)",
+            host,
+            port,
+            exc,
+        )
\ No newline at end of file
diff --git a/signage/slidestore.py b/signage/slidestore.py
index f56a742..df9580b 100644
--- a/signage/slidestore.py
+++ b/signage/slidestore.py
@@ -1,276 +1,232 @@
 """
 Slide Store Module
 
-This module provides functionality for managing slides in the GTK Signage application.
-It handles loading, saving, and filtering slides based on their active status.
-The slides are stored in a JSON file and accessed through the SlideStore class.
+Manages loading, saving, and filtering slides for the GTK Signage application.
+Slides are stored in a JSON file whose location is defined via INI config.
 """
-import os
+
+from __future__ import annotations
+
 import json
 import logging
+import os
 from datetime import datetime
+from typing import List
+
+from signage.config import load_config
+from signage.jsonfile import JSONFileHandler
+from signage.models import Slide
 
-from .jsonfile import JSONFileHandler
-from .models import Slide
 
-# Get logger for this module
 logger = logging.getLogger(__name__)
+config = load_config()
+
+
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
+
+SLIDE_FILE = os.path.expanduser(
+    config.get("slides", "file", fallback="slides.json")
+)
+
+
+# ------------------------------------------------------------
+# Slide Store
+# ------------------------------------------------------------
 
 class SlideStore:
     """
-    A static utility class for managing slides.
-    
-    This class provides methods for loading, saving, and filtering slides.
-    It maintains a cache of slides and monitors the slide file for changes.
-    All methods are class methods as this is designed as a static utility class.
+    Static utility class for managing slides.
+
+    Uses a JSON file as backing storage and keeps an in-memory cache
+    that reloads automatically when the file changes.
     """
-    SLIDE_FILE = "slides.json"
-    _slides = []
-    _last_modified_time = 0
+
+    _slides: List[Slide] = []
+    _last_mtime: float = 0.0
     _file_handler = JSONFileHandler(SLIDE_FILE)
 
+    # --------------------------------------------------------
+
     @classmethod
-    def _load_slides(cls):
+    def _load_slides(cls) -> None:
         """
-        Load slides from the JSON file into memory.
-        
-        This private method reads the slide data from the JSON file,
-        converts it to Slide objects, and stores them in the _slides class variable.
-        
-        If any errors occur during loading or parsing, the _slides list will be empty.
+        Load slides from disk into memory.
         """
-        logger.debug(f"Loading slides from {cls.SLIDE_FILE}")
+        logger.debug("Loading slides from %s", SLIDE_FILE)
+
         try:
-            raw_data = cls._file_handler.load()
-            logger.debug(f"Loaded {len(raw_data)} raw slide entries")
-            
+            raw = cls._file_handler.load()
+        except (IOError, json.JSONDecodeError) as exc:
+            logger.error("Failed to load slides file: %s", exc)
             cls._slides = []
-            for i, item in enumerate(raw_data):
-                try:
-                    start_time = datetime.fromisoformat(item["start"]) if item.get("start") else None
-                    end_time = datetime.fromisoformat(item["end"]) if item.get("end") else None
-                    
-                    slide = Slide(
-                        source=item["source"],
-                        duration=item["duration"],
-                        start=start_time,
-                        end=end_time,
-                        hide=item.get("hide", False)
-                    )
-                    cls._slides.append(slide)
-                    logger.debug(f"Processed slide {i+1}/{len(raw_data)}: {slide.source}")
-                except (KeyError, ValueError) as e:
-                    logger.error(f"Error parsing slide data at index {i}: {e}")
-                    logger.debug(f"Problematic slide data: {item}")
-            
-            logger.info(f"Successfully loaded {len(cls._slides)} slides")
-        except (IOError, ValueError, json.JSONDecodeError) as e:
-            logger.error(f"Error loading slides file: {e}")
-            cls._slides = []
-            logger.info("Initialized with empty slide list due to error")
+            return
+
+        slides: List[Slide] = []
+
+        for idx, item in enumerate(raw):
+            try:
+                start = (
+                    datetime.fromisoformat(item["start"])
+                    if item.get("start")
+                    else None
+                )
+                end = (
+                    datetime.fromisoformat(item["end"])
+                    if item.get("end")
+                    else None
+                )
+
+                slide = Slide(
+                    source=item["source"],
+                    duration=int(item["duration"]),
+                    start=start,
+                    end=end,
+                    hide=bool(item.get("hide", False)),
+                )
+                slides.append(slide)
+
+            except Exception as exc:
+                logger.error(
+                    "Invalid slide at index %d: %s", idx, exc
+                )
+                logger.debug("Slide data: %r", item)
+
+        cls._slides = slides
+        logger.info("Loaded %d slides", len(slides))
+
+    # --------------------------------------------------------
 
     @classmethod
-    def get_active_slides(cls):
+    def _reload_if_needed(cls) -> None:
         """
-        Get all currently active slides.
-        
-        This method checks if the slides file has been modified since the last load,
-        reloads the slides if necessary, and returns only the active slides.
-        
-        Returns:
-            list: A list of Slide objects that are currently active.
+        Reload slides if the backing file has changed.
         """
-        logger.debug("Checking for active slides")
         try:
-            current_mtime = os.path.getmtime(cls.SLIDE_FILE)
-            if current_mtime != cls._last_modified_time:
-                logger.info(f"Slide file modified (mtime: {current_mtime}, last: {cls._last_modified_time})")
-                cls._last_modified_time = current_mtime
-                cls._load_slides()
-            else:
-                logger.debug("Slide file unchanged since last check")
+            mtime = os.path.getmtime(SLIDE_FILE)
         except FileNotFoundError:
-            logger.warning(f"Slide file not found: {cls.SLIDE_FILE}")
+            if cls._slides:
+                logger.warning("Slides file missing, clearing cache")
             cls._slides = []
-        
-        active_slides = [slide for slide in cls._slides if slide.is_active()]
-        logger.debug(f"Found {len(active_slides)}/{len(cls._slides)} active slides")
-        
-        if not active_slides and cls._slides:
-            logger.info("No active slides found despite having slides loaded")
-            
-        return active_slides
+            cls._last_mtime = 0
+            return
+
+        if mtime != cls._last_mtime:
+            logger.info(
+                "Slides file changed (mtime %s â†’ %s)",
+                cls._last_mtime,
+                mtime,
+            )
+            cls._last_mtime = mtime
+            cls._load_slides()
+
+    # --------------------------------------------------------
+
+    @classmethod
+    def get_active_slides(cls) -> List[Slide]:
+        """
+        Return all currently active slides.
+        """
+        cls._reload_if_needed()
+
+        active = [s for s in cls._slides if s.is_active()]
+        logger.debug(
+            "Active slides: %d / %d", len(active), len(cls._slides)
+        )
+        return active
+
+    # --------------------------------------------------------
+
+    @classmethod
+    def get_all_slides(cls) -> List[Slide]:
+        """
+        Return all slides regardless of active status.
+        """
+        cls._reload_if_needed()
+        return list(cls._slides)
+
+    # --------------------------------------------------------
+
+    @classmethod
+    def force_reload(cls) -> None:
+        """
+        Force reload on next access.
+        """
+        cls._last_mtime = 0
+
+    # --------------------------------------------------------
 
     @classmethod
-    def force_reload(cls):
+    def save_slides(cls, slides: List[Slide]) -> None:
         """
-        Force a reload of slides on the next access.
-        
-        This method resets the last modified time to ensure that the slides
-        will be reloaded from the file the next time they are accessed.
+        Persist a list of Slide objects to disk.
         """
-        logger.debug("Forcing reload of slides on next access")
-        cls._last_modified_time = 0
+        data = []
+
+        for s in slides:
+            data.append(
+                {
+                    "source": s.source,
+                    "duration": s.duration,
+                    "start": s.start.isoformat() if s.start else None,
+                    "end": s.end.isoformat() if s.end else None,
+                    "hide": s.hide,
+                }
+            )
+
+        cls._file_handler.save(data)
+        logger.info("Saved %d slides", len(data))
+        cls.force_reload()
+
+    # --------------------------------------------------------
 
     @classmethod
-    def add_slide(cls, slide_data):
+    def add_slide(cls, slide_data: dict) -> None:
         """
-        Add a new slide to the store.
-        
-        Args:
-            slide_data (dict): A dictionary containing the slide data.
-                Must include 'source' and 'duration' keys.
-                May optionally include 'start', 'end', and 'hide' keys.
-                
-        Raises:
-            ValueError: If any required fields are missing or invalid.
-            TypeError: If any fields have incorrect types.
-            
-        Note:
-            This method loads the current slides from the file,
-            adds the new slide, and saves the updated list back to the file.
+        Add a single slide entry and persist immediately.
         """
-        logger.info(f"Adding new slide with source: {slide_data.get('source', 'unknown')}")
-        logger.debug(f"Full slide data: {slide_data}")
-        
-        # Validate required fields
-        required_fields = ["source", "duration"]
-        for key in required_fields:
+        required = ("source", "duration")
+        for key in required:
             if key not in slide_data:
-                logger.error(f"Cannot add slide: Missing required field: {key}")
                 raise ValueError(f"Missing required field: {key}")
-        
-        # Validate source
-        source = slide_data["source"]
-        if not isinstance(source, str):
-            logger.error("Source must be a string")
-            raise TypeError("Source must be a string")
-        if not source.strip():
-            logger.error("Source cannot be empty")
+
+        source = str(slide_data["source"]).strip()
+        if not source:
             raise ValueError("Source cannot be empty")
-        
-        # Validate duration
-        try:
-            duration = int(slide_data["duration"])
-            if duration <= 0:
-                logger.error("Duration must be positive")
-                raise ValueError("Duration must be positive")
-        except (ValueError, TypeError):
-            logger.error("Duration must be an integer")
-            raise TypeError("Duration must be an integer")
-        
-        # Validate start and end times
+
+        duration = int(slide_data["duration"])
+        if duration <= 0:
+            raise ValueError("Duration must be positive")
+
         start = slide_data.get("start")
         end = slide_data.get("end")
-        
-        if start:
-            try:
-                if isinstance(start, str):
-                    start = datetime.fromisoformat(start)
-            except ValueError:
-                logger.error("Invalid start time format")
-                raise ValueError("Invalid start time format")
-        
-        if end:
-            try:
-                if isinstance(end, str):
-                    end = datetime.fromisoformat(end)
-            except ValueError:
-                logger.error("Invalid end time format")
-                raise ValueError("Invalid end time format")
-        
+
+        if isinstance(start, str):
+            start = datetime.fromisoformat(start)
+        if isinstance(end, str):
+            end = datetime.fromisoformat(end)
+
         if start and end and start >= end:
-            logger.error("Start time must be before end time")
             raise ValueError("Start time must be before end time")
-        
-        # Validate hide flag
-        hide = slide_data.get("hide", False)
-        if not isinstance(hide, bool):
-            try:
-                # Convert to boolean if it's a string like "true" or "false"
-                if isinstance(hide, str):
-                    hide = hide.lower() in ("true", "yes", "1", "t", "y")
-                else:
-                    hide = bool(hide)
-            except:
-                logger.error("Hide flag must be a boolean")
-                raise TypeError("Hide flag must be a boolean")
 
-        try:
-            logger.debug("Loading current slides data")
-            current_data = cls._file_handler.load()
-            logger.debug(f"Loaded {len(current_data)} existing slides")
-        except (IOError, json.JSONDecodeError) as e:
-            logger.error(f"Error loading slides for adding new slide: {e}")
-            logger.info("Initializing with empty slide list due to error")
-            current_data = []
-
-        # Prepare the new slide data
-        new_slide = {
-            "source": source,
-            "duration": duration,
-            "start": start.isoformat() if start else None,
-            "end": end.isoformat() if end else None,
-            "hide": hide
-        }
-        
-        logger.debug(f"Prepared new slide data: {new_slide}")
-        current_data.append(new_slide)
+        hide = bool(slide_data.get("hide", False))
 
         try:
-            logger.debug(f"Saving updated slides data with {len(current_data)} slides")
-            cls._file_handler.save(current_data)
-            logger.info(f"Successfully added new slide, total slides: {len(current_data)}")
-            cls.force_reload()
-        except (IOError, PermissionError) as e:
-            logger.error(f"Error saving slides: {e}")
-            raise
+            existing = cls._file_handler.load()
+        except Exception:
+            existing = []
 
-    @classmethod
-    def save_slides(cls, slides):
-        """
-        Save a list of slides to the file.
-        
-        This method converts the Slide objects to dictionaries and saves them to the file.
-        It then forces a reload to ensure the in-memory slides are up-to-date.
-        
-        Args:
-            slides (list): A list of Slide objects to save.
-        """
-        logger.info(f"Saving {len(slides)} slides to file")
-        
-        data = []
-        for i, s in enumerate(slides):
-            slide_dict = {
-                "source": s.source,
-                "duration": s.duration,
-                "start": s.start.isoformat() if s.start else None,
-                "end": s.end.isoformat() if s.end else None,
-                "hide": s.hide
+        existing.append(
+            {
+                "source": source,
+                "duration": duration,
+                "start": start.isoformat() if start else None,
+                "end": end.isoformat() if end else None,
+                "hide": hide,
             }
-            data.append(slide_dict)
-            logger.debug(f"Prepared slide {i+1}/{len(slides)} for saving: {s.source}")
-        
-        try:
-            logger.debug(f"Writing {len(data)} slides to {cls.SLIDE_FILE}")
-            cls._file_handler.save(data)
-            logger.info(f"Successfully saved {len(data)} slides")
-            cls.force_reload()
-        except Exception as e:
-            logger.error(f"Error saving slides to file: {e}")
-            raise
+        )
 
-    @classmethod
-    def get_all_slides(cls):
-        """
-        Get all slides, regardless of their active status.
-        
-        This method loads the slides from the file if necessary and returns all of them.
-        
-        Returns:
-            list: A list of all Slide objects.
-        """
-        logger.debug("Getting all slides, regardless of active status")
-        cls._load_slides()
-        logger.debug(f"Returning {len(cls._slides)} total slides")
-        return cls._slides
+        cls._file_handler.save(existing)
+        logger.info("Added slide: %s", source)
+        cls.force_reload()
\ No newline at end of file
diff --git a/signage/system_monitor.py b/signage/system_monitor.py
index 074a127..2c52046 100644
--- a/signage/system_monitor.py
+++ b/signage/system_monitor.py
@@ -1,120 +1,149 @@
 """
 System Monitor Module
 
-This module provides functions for monitoring system resources like CPU, memory, and temperature.
-It uses the psutil library to gather system information.
+Provides system resource metrics such as CPU, memory, disk, and temperature.
+All behavior is driven by configuration and safe for Flatpak environments.
 """
-import os
-import platform
+
+from __future__ import annotations
+
 import logging
+import platform
+from typing import Optional, Dict, Any
+
 import psutil
 
-# Get logger for this module
+from signage.config import load_config
+
+
 logger = logging.getLogger(__name__)
+config = load_config()
+
+
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
 
-def get_cpu_usage():
+DISK_PATH = config.get("system", "disk_path", fallback="/")
+ENABLE_TEMPERATURE = config.getboolean(
+    "system", "enable_temperature", fallback=True
+)
+
+
+# ------------------------------------------------------------
+# CPU
+# ------------------------------------------------------------
+
+def get_cpu_usage() -> Optional[float]:
     """
-    Get the current CPU usage as a percentage.
-    
+    Get current CPU usage percentage.
+
     Returns:
-        float: CPU usage percentage (0-100).
+        float or None
     """
     try:
         return psutil.cpu_percent(interval=0.5)
-    except Exception as e:
-        logger.error(f"Error getting CPU usage: {e}")
+    except Exception as exc:
+        logger.error("CPU usage error: %s", exc)
         return None
 
-def get_memory_usage():
+
+# ------------------------------------------------------------
+# Memory
+# ------------------------------------------------------------
+
+def get_memory_usage() -> Optional[Dict[str, Any]]:
     """
-    Get the current memory usage.
-    
+    Get memory usage statistics.
+
     Returns:
-        dict: Memory usage information with the following keys:
-            - total: Total physical memory in bytes
-            - available: Available memory in bytes
-            - used: Used memory in bytes
-            - percent: Percentage of memory used (0-100)
+        dict or None
     """
     try:
-        memory = psutil.virtual_memory()
+        mem = psutil.virtual_memory()
         return {
-            "total": memory.total,
-            "available": memory.available,
-            "used": memory.used,
-            "percent": memory.percent
+            "total": mem.total,
+            "available": mem.available,
+            "used": mem.used,
+            "percent": mem.percent,
         }
-    except Exception as e:
-        logger.error(f"Error getting memory usage: {e}")
+    except Exception as exc:
+        logger.error("Memory usage error: %s", exc)
         return None
 
-def get_disk_usage():
+
+# ------------------------------------------------------------
+# Disk
+# ------------------------------------------------------------
+
+def get_disk_usage() -> Optional[Dict[str, Any]]:
     """
-    Get the disk usage for the root partition.
-    
+    Get disk usage statistics for configured path.
+
     Returns:
-        dict: Disk usage information with the following keys:
-            - total: Total disk space in bytes
-            - used: Used disk space in bytes
-            - free: Free disk space in bytes
-            - percent: Percentage of disk used (0-100)
+        dict or None
     """
     try:
-        disk = psutil.disk_usage('/')
+        disk = psutil.disk_usage(DISK_PATH)
         return {
+            "path": DISK_PATH,
             "total": disk.total,
             "used": disk.used,
             "free": disk.free,
-            "percent": disk.percent
+            "percent": disk.percent,
         }
-    except Exception as e:
-        logger.error(f"Error getting disk usage: {e}")
+    except Exception as exc:
+        logger.error("Disk usage error (%s): %s", DISK_PATH, exc)
         return None
 
-def get_temperature():
+
+# ------------------------------------------------------------
+# Temperature
+# ------------------------------------------------------------
+
+def get_temperature() -> Optional[float]:
     """
-    Get the CPU temperature if available.
-    
+    Get CPU temperature in Celsius if available and enabled.
+
     Returns:
-        float or None: CPU temperature in Celsius, or None if not available.
+        float or None
     """
+    if not ENABLE_TEMPERATURE:
+        return None
+
     try:
-        # Temperature is not available on all systems
         temps = psutil.sensors_temperatures()
         if not temps:
             return None
-        
-        # Try to find CPU temperature
-        # Different systems report temperature differently
+
+        # Prefer CPU-like sensors
         for name, entries in temps.items():
-            if any(x.lower() in name.lower() for x in ['cpu', 'core', 'package']):
-                return entries[0].current
-            
-        # If we couldn't find a CPU temperature, return the first one
-        if temps:
-            first_sensor = next(iter(temps.values()))
-            if first_sensor:
-                return first_sensor[0].current
-                
+            lname = name.lower()
+            if any(k in lname for k in ("cpu", "core", "package")):
+                if entries:
+                    return entries[0].current
+
+        # Fallback to first available sensor
+        first = next(iter(temps.values()), None)
+        if first:
+            return first[0].current
+
         return None
-    except Exception as e:
-        logger.error(f"Error getting temperature: {e}")
+    except Exception as exc:
+        logger.debug("Temperature unavailable: %s", exc)
         return None
 
-def get_system_info():
+
+# ------------------------------------------------------------
+# System Info
+# ------------------------------------------------------------
+
+def get_system_info() -> Optional[Dict[str, Any]]:
     """
-    Get basic system information.
-    
+    Get basic system metadata.
+
     Returns:
-        dict: System information with the following keys:
-            - system: Operating system name
-            - node: Network node name
-            - release: Operating system release
-            - version: Operating system version
-            - machine: Machine type
-            - processor: Processor type
-            - cpu_count: Number of CPUs
-            - boot_time: System boot time (timestamp)
+        dict or None
     """
     try:
         return {
@@ -125,28 +154,28 @@ def get_system_info():
             "machine": platform.machine(),
             "processor": platform.processor(),
             "cpu_count": psutil.cpu_count(),
-            "boot_time": psutil.boot_time()
+            "boot_time": psutil.boot_time(),
         }
-    except Exception as e:
-        logger.error(f"Error getting system info: {e}")
+    except Exception as exc:
+        logger.error("System info error: %s", exc)
         return None
 
-def get_all_stats():
+
+# ------------------------------------------------------------
+# Aggregate
+# ------------------------------------------------------------
+
+def get_all_stats() -> Dict[str, Any]:
     """
-    Get all system statistics in a single call.
-    
+    Get all system statistics in one call.
+
     Returns:
-        dict: All system statistics with the following keys:
-            - cpu: CPU usage percentage
-            - memory: Memory usage information
-            - disk: Disk usage information
-            - temperature: CPU temperature in Celsius (if available)
-            - system_info: Basic system information
+        dict
     """
     return {
         "cpu": get_cpu_usage(),
         "memory": get_memory_usage(),
         "disk": get_disk_usage(),
         "temperature": get_temperature(),
-        "system_info": get_system_info()
+        "system_info": get_system_info(),
     }
\ No newline at end of file
diff --git a/signage/ui.py b/signage/ui.py
index d6aec71..7aeaacb 100644
--- a/signage/ui.py
+++ b/signage/ui.py
@@ -1,51 +1,59 @@
 """
 UI Module
 
-This module provides the GTK-based user interface for the signage application.
-It creates a window with a WebKit2 webview that displays slides in a loop.
-The slides are loaded from the SlideStore and displayed according to their
-configured duration.
+GTK-based UI for the signage application.
+Displays slides using a WebKit2 WebView in a fullscreen window.
 """
-import os
+
+from __future__ import annotations
+
 import sys
 import logging
 import urllib.parse
+import threading
 
 import gi
-from dotenv import load_dotenv
+gi.require_version("Gtk", "3.0")
+gi.require_version("WebKit2", "4.1")
+
 from gi.repository import Gtk, WebKit2, GLib
 
+from signage.config import load_config
 from signage.slidestore import SlideStore
 from signage.cache import URLCache
 
-load_dotenv()
 
-# Read host/port from .env
-HOST = os.getenv("FLASK_HOST", "127.0.0.1")
-PORT = os.getenv("FLASK_PORT", "5000")
-USE_SSL = os.getenv("USE_SSL", "false").lower() == "true"
+# ------------------------------------------------------------
+# Configuration
+# ------------------------------------------------------------
+
+config = load_config()
+
+FLASK_HOST = config.get("flask", "host", fallback="127.0.0.1")
+FLASK_PORT = config.getint("flask", "port", fallback=5000)
+USE_SSL = config.getboolean("flask", "use_ssl", fallback=False)
 
-# Normalize localhost for display
-DISPLAY_HOST = "localhost" if HOST in ["0.0.0.0", "127.0.0.1"] else HOST
+DISPLAY_HOST = "localhost" if FLASK_HOST in ("0.0.0.0", "127.0.0.1") else FLASK_HOST
 SCHEME = "https" if USE_SSL else "http"
-ADMIN_URL = f"{SCHEME}://{DISPLAY_HOST}:{PORT}/admin"
+ADMIN_URL = f"{SCHEME}://{DISPLAY_HOST}:{FLASK_PORT}/admin"
+
+CACHE_CLEANUP_INTERVAL = config.getint(
+    "cache", "cleanup_interval_seconds", fallback=6 * 60 * 60
+)
+
+
+# ------------------------------------------------------------
+# Window
+# ------------------------------------------------------------
 
 class SignageWindow(Gtk.Window):
     """
-    Main window for the GTK Signage application.
-    
-    This class creates a GTK window with a WebKit2 webview that displays slides
-    in a continuous loop. It handles the display logic, including timing between
-    slides and showing a message when no slides are available.
+    Main GTK window that displays signage slides.
     """
-    def __init__(self):
-        """
-        Initialize the SignageWindow.
-        
-        Creates a GTK window with a WebKit2 webview, sets up the initial size,
-        and starts the slide loop after a 1-second delay.
-        """
-        Gtk.Window.__init__(self, title="Signage")
+
+    def __init__(self) -> None:
+        super().__init__(title="Signage")
+
         self.set_default_size(1280, 720)
         self.connect("destroy", self.on_destroy)
 
@@ -55,268 +63,146 @@ class SignageWindow(Gtk.Window):
 
         self.slide_index = 0
         self.current_slide = None
-        self.show_all()
-        
-        # Track URLs that are currently being cached
-        self._caching_urls = set()
-        
-        # Track the last displayed slide to avoid redundant caching
         self._last_displayed_slide = None
+        self._caching_urls: set[str] = set()
+
+        self.show_all()
 
-        # Run cache cleanup on startup and then every 6 hours
+        # Cache maintenance
         self.cleanup_cache()
-        GLib.timeout_add_seconds(6 * 60 * 60, self.cleanup_cache)
-        
+        GLib.timeout_add_seconds(CACHE_CLEANUP_INTERVAL, self.cleanup_cache)
+
+        # Start slideshow
         GLib.timeout_add_seconds(1, self.slide_loop)
-    
-    def is_url(self, source):
-        """
-        Check if a source is a URL.
-        
-        Args:
-            source (str): The source to check.
-            
-        Returns:
-            bool: True if the source is a URL, False otherwise.
-        """
+
+    # --------------------------------------------------------
+    # Helpers
+    # --------------------------------------------------------
+
+    @staticmethod
+    def is_url(source: str) -> bool:
         parsed = urllib.parse.urlparse(source)
-        return parsed.scheme in ('http', 'https')
-    
-    def ensure_cached(self, url):
-        """
-        Ensure that a URL is cached.
-        
-        This method checks if a URL needs to be cached and caches it if necessary.
-        It uses a separate thread to avoid blocking the main thread.
-        It also tracks which URLs are currently being cached to avoid starting
-        multiple caching threads for the same URL.
-        
-        Args:
-            url (str): The URL to cache.
-        """
-        try:
-            # Skip if this URL is already being cached
-            if url in self._caching_urls:
-                logging.debug(f"URL already being cached, skipping: {url}")
-                return
-                
-            # Check if the URL is already cached and not expired
-            if not URLCache.is_cached(url) or URLCache.is_cache_expired(url):
-                logging.info(f"Caching URL: {url}")
-                # Add to the set of URLs being cached
-                self._caching_urls.add(url)
-                # Use a separate thread to cache the URL
-                import threading
-                thread = threading.Thread(target=self._cache_url_thread, args=(url,))
-                thread.daemon = True  # Thread will exit when main thread exits
-                thread.start()
-            else:
-                logging.debug(f"URL already cached: {url}")
-        except Exception as e:
-            logging.error(f"Error ensuring URL is cached: {e}")
-            
-    def _cache_url_thread(self, url):
-        """
-        Cache a URL in a separate thread.
-        
-        This method is called from a separate thread to avoid blocking the main thread.
-        It removes the URL from the set of URLs being cached when it completes,
-        whether it succeeds or fails.
-        
-        Args:
-            url (str): The URL to cache.
-        """
+        return parsed.scheme in ("http", "https")
+
+    def ensure_cached(self, url: str) -> None:
+        if url in self._caching_urls:
+            return
+
+        if URLCache.is_cached(url) and not URLCache.is_cache_expired(url):
+            return
+
+        logging.info("Caching URL: %s", url)
+        self._caching_urls.add(url)
+
+        thread = threading.Thread(
+            target=self._cache_url_thread,
+            args=(url,),
+            daemon=True,
+        )
+        thread.start()
+
+    def _cache_url_thread(self, url: str) -> None:
         try:
-            logging.debug(f"Caching URL in thread: {url}")
             URLCache.cache_url(url)
-            logging.debug(f"Finished caching URL in thread: {url}")
-        except Exception as e:
-            logging.error(f"Error caching URL in thread: {url}, {e}")
+        except Exception as exc:
+            logging.error("Error caching URL %s: %s", url, exc)
         finally:
-            # Remove the URL from the set of URLs being cached
-            if url in self._caching_urls:
-                self._caching_urls.remove(url)
-    
-    def cleanup_cache(self):
-        """
-        Clean up expired cache files.
-        
-        This method removes all cached files that are older than the expiry time.
-        
-        Returns:
-            bool: Always returns True to ensure the timeout is repeated.
-        """
+            self._caching_urls.discard(url)
+
+    def cleanup_cache(self) -> bool:
         logging.info("Running cache cleanup")
         try:
             URLCache.cleanup_expired_cache()
-        except Exception as e:
-            logging.error(f"Error cleaning up cache: {e}")
+        except Exception as exc:
+            logging.error("Cache cleanup error: %s", exc)
         return True
-    
-    def on_load_failed(self, webview, event, uri, error):
-        """
-        Handle load failures by falling back to cached content.
-        
-        This method is called when a web page fails to load. It attempts to
-        load the cached version of the page instead.
-        
-        Args:
-            webview (WebKit2.WebView): The webview that failed to load.
-            event: The load event.
-            uri (str): The URI that failed to load.
-            error: The error that occurred.
-            
-        Returns:
-            bool: True to stop the error from propagating, False otherwise.
-        """
-        logging.error(f"Failed to load {uri}: {error}")
-        
+
+    # --------------------------------------------------------
+    # WebKit callbacks
+    # --------------------------------------------------------
+
+    def on_load_failed(self, webview, load_event, uri, error) -> bool:
+        logging.error("Failed to load %s: %s", uri, error)
+
         if self.current_slide and self.is_url(self.current_slide.source):
-            cached_url = URLCache.get_cached_url(self.current_slide.source)
-            if cached_url != self.current_slide.source:
-                logging.info(f"Falling back to cached version: {cached_url}")
-                webview.load_uri(cached_url)
+            cached = URLCache.get_cached_url(self.current_slide.source)
+            if cached != self.current_slide.source:
+                logging.info("Falling back to cached version: %s", cached)
+                webview.load_uri(cached)
                 return True
-        
+
         return False
 
-    def slide_loop(self):
-        """
-        Main loop for displaying slides.
-        
-        This method is called repeatedly to cycle through the active slides.
-        If no slides are active, it displays a message prompting the user to
-        visit the admin console. Otherwise, it displays each slide for its
-        configured duration before moving to the next one.
-        
-        For URL slides, this method ensures that the content is cached locally
-        before displaying it. If the URL cannot be loaded (e.g., due to network
-        issues), the cached version is displayed instead.
-        
-        Returns:
-            bool: Always returns False to indicate that the timeout should not
-                  be automatically repeated. Instead, a new timeout is scheduled
-                  with the appropriate delay for the next slide.
-        """
-        active_slides = SlideStore.get_active_slides()
-
-        if not active_slides:
-            logging.info("No active slides")
-            self.slide_index = 0
-            self.current_slide = None
-            self._last_displayed_slide = None
-
-            # Show message prompting user to visit the admin console
-            self.webview.load_html(
-                f"""
-                <html>
-                    <head>
-                        <style>
-                            body {{
-                                font-family: sans-serif;
-                                text-align: center;
-                                margin-top: 20%;
-                                color: #444;
-                            }}
-                            a {{
-                                color: #0066cc;
-                                text-decoration: none;
-                                font-weight: bold;
-                            }}
-                        </style>
-                    </head>
-                    <body>
-                        <h1>No slides yet</h1>
-                        <p>Add some slides in the Admin Console.</p>
-                        <p>URL: <b>{ADMIN_URL}</b></p>
-                    </body>
-                </html>
-                """,
-                "about:blank"
-            )
+    # --------------------------------------------------------
+    # Slideshow
+    # --------------------------------------------------------
 
+    def slide_loop(self) -> bool:
+        slides = SlideStore.get_active_slides()
+
+        if not slides:
+            self._show_no_slides_message()
             GLib.timeout_add_seconds(5, self.slide_loop)
             return False
 
-        self.slide_index %= len(active_slides)
-        self.current_slide = active_slides[self.slide_index]
+        self.slide_index %= len(slides)
+        self.current_slide = slides[self.slide_index]
         source = self.current_slide.source
-        
-        # Check if we're displaying the same slide as before
-        same_slide = (self._last_displayed_slide is not None and 
-                     self.current_slide.source == self._last_displayed_slide.source)
-        
-        # Update the last displayed slide
+
+        same_slide = (
+            self._last_displayed_slide is not None
+            and source == self._last_displayed_slide.source
+        )
         self._last_displayed_slide = self.current_slide
-        
-        # Log the slide we're showing
-        logging.info(f"Showing slide: {source}")
-        
-        # Handle URL slides with caching
+
+        logging.info("Showing slide: %s", source)
+
         if self.is_url(source):
-            try:
-                # Only start caching if this is a new slide or if caching previously failed
-                if not same_slide or not URLCache.is_cached(source):
-                    # Start caching the URL in the background, but don't wait for it to complete
-                    self.ensure_cached(source)
-                
-                # Try to load the original URL first
-                self.webview.load_uri(source)
-                
-                # Note: The caching happens in a separate thread, so it won't block the slide loop
-                # If the URL can't be loaded, the on_load_failed handler will try to use the cached version
-            except Exception as e:
-                logging.error(f"Error loading URL {source}: {e}")
-                
-                # Fall back to cached version if available
-                cached_url = URLCache.get_cached_url(source)
-                if cached_url != source:
-                    logging.info(f"Falling back to cached version: {cached_url}")
-                    self.webview.load_uri(cached_url)
-                else:
-                    logging.error(f"No cached version available for {source}")
-                    self.webview.load_html(
-                        f"""
-                        <html>
-                            <head>
-                                <style>
-                                    body {{
-                                        font-family: sans-serif;
-                                        text-align: center;
-                                        margin-top: 20%;
-                                        color: #444;
-                                    }}
-                                </style>
-                            </head>
-                            <body>
-                                <h1>Error Loading Content</h1>
-                                <p>Could not load: {source}</p>
-                                <p>No cached version available.</p>
-                            </body>
-                        </html>
-                        """,
-                        "about:blank"
-                    )
+            if not same_slide:
+                self.ensure_cached(source)
+            self.webview.load_uri(source)
         else:
-            # Non-URL slides (e.g., local files) are loaded directly
             self.webview.load_uri(source)
 
         delay = self.current_slide.duration
-        self.slide_index = (self.slide_index + 1) % len(active_slides)
-        GLib.timeout_add_seconds(delay, self.slide_loop)
+        self.slide_index += 1
 
+        GLib.timeout_add_seconds(delay, self.slide_loop)
         return False
 
-    def on_destroy(self, *args):
-        """
-        Handle the window destroy event.
-        
-        This method is called when the window is closed. It stops the GTK main loop
-        and exits the application.
-        
-        Args:
-            *args: Variable length argument list (not used).
-        """
+    def _show_no_slides_message(self) -> None:
+        self.slide_index = 0
+        self.current_slide = None
+        self._last_displayed_slide = None
+
+        self.webview.load_html(
+            f"""
+            <html>
+              <head>
+                <style>
+                  body {{
+                    font-family: sans-serif;
+                    text-align: center;
+                    margin-top: 20%;
+                    color: #444;
+                  }}
+                </style>
+              </head>
+              <body>
+                <h1>No slides yet</h1>
+                <p>Add slides in the admin console.</p>
+                <p><b>{ADMIN_URL}</b></p>
+              </body>
+            </html>
+            """,
+            "about:blank",
+        )
+
+    # --------------------------------------------------------
+    # Shutdown
+    # --------------------------------------------------------
+
+    def on_destroy(self, *_args) -> None:
         logging.info("GTK window closed. Shutting down.")
         Gtk.main_quit()
-        sys.exit(0)
+        sys.exit(0)
\ No newline at end of file
